# 关于REST API
## 1）要务实：
    REST API，你应当接受并使用 JSON 进行响应。不要用 XML。不要用别的什么东西。就是 JSON
    JSON 更容易使用、更容易书写、更容易阅读：任何人，哪怕是你的祖母都能阅读。
    JSON 的速度更快，而且占用的内存空间更少。
    JSON 不需要专门的依赖关系或包来解析它。
    每一种有意义的程序设计语言都能为 JSON 提供良好的支持。
## 2）要有条理：
## 3）重语义：
    重视取名
    不要用动词，而是用名词。
        之所以要使用名词，是因为当你进行 HTTP 请求时，就像我们前面提到的，你使用的是动词。每个 HTTP 方法（GET、POST、PUT、PATCH）在英语中都是一个动词。所以，用双重动词就没有任何意义了，对吧！如果你将 API 端点命名为 /getUsers，并且你在进行一个 GET 请求来查看所有的用户，那么你读这个语句的时候会觉得很有趣。GET getUsers。没有意义。

    用复数替代单数。
        另一种常见情况是用单数而不是复数的端点名称。这当然大错特错。你需要 API 的端点保持一致、简单和逻辑性。如果你使用了复数，你可以为每一种 HTTP 方法提供同样的 URI。如果你做的是 GET /users，那么你将会把所有的用户都列出来，而你在做 POST /users 时，你就会创建一个用户。因此，同样的 URI，使用不同的 HTTP 方法（动词）。更酷的是，你可以请求 GET /users/:id 来获取信息，以便了解更多的细节。所以，就像你所见：它仍然是相同的起始资源名称，只不过有了更多的深度。假如你使用单数，那么 GET /user 表示你想要拥有一个用户，并且你还需要在其他场合中使用更多的 URI。复数就更有意义了。
    
    良好的示范：
        GET /users
        POST /users
        GET /users/23
        PUT /users/23
        DELETE /users/23
        GET /users/23/comments
    
    错误的示范：
        GET /user/23
        GET /listAllUsers
        POST /user/create
        PUT /updateUser/23
        GET /userComments/23

    尽量使用单个单词而不是多个单词。
        如果你一定要使用多个单词，那么在它们之间使用连字符。看在老天爷的份上，在 URI 中使用所有的小写字母。
    
    作为本节的总结，我将简单地介绍一下 JSON 键在请求和响应数据中的命名规则。对于这一问题，存在着大量争议，特别是考虑到有三种可能的情况：camelCase（驼峰式大小写）、snake_case（蛇形命名法） 和 spinal-case（脊柱命名法）。同样，没有人可以阻止你使用其中任何一种，从理论上讲，你是不会出错的。不过，我推荐使用 snake_case。为什么？Stripe 使用它。PayPal 使用它。Facebook 也使用它。你知道吗？就我个人而言，我发现这样我们就可以 100% 地弄清楚了：因为更容易阅读，这就是为什么我们所有的 API 都使用 snake_case。还有一些类似的研究显示，snake_case 在可读性上要优于 camelCase。

## 4) API 的版本
   REST APIs 基本上是以 URI 为基础的，我想我们应该保持这一传统，使用基于 URI 的版本管理。这方面的一些例子包括：
    api.domain.com/v1/auth/login
    api.domain.com/v1.2/auth/login
    api.domain.com/v1.4.5/auth/login
    api.domain.com/v2/auth/login  


## 5）要一致
“一致性是将平庸转化为卓越的原因”。优秀的 API 的一个特点就是它的一致性。首先，我的目标是资源 / 模型的一致性，然后是其他领域，如命名、URI、HTTP 代码和类似的。符合陌生人默认的猜想。

正如我们现在所知道的，API 可以归结为资源。一种资源可以是任何东西，包括用户、文章、书籍、产品等等。每一种资源都可以包含多个属性、对象或数组。资源是结构化的，基于你在数据库中的数据或其他业务逻辑。你的 API 要取得成功，关键在于保持你的资源响应。你无法将你的端点返回完全不同的资源结构。

### 必须要有一致的返回结构，符合预期，做一定稳定的积累。

虽然这听上去很有吸引力，也可能是优化事物的方法，但是你最好不要这么做。实施你的 API 的移动开发人员将遵循你所提供的结构，就如同遵循了《圣经》。如果你在每个端点上发送不同的东西，那么他 / 她的日子就会很糟糕，没有人希望这样。所以，要尽量总是发送相同的资源结构。如果你没有数据，则将其作为空值，或者对象，或者数据来发送。让我们来谈谈现实，假定我们有“文章”资源，有时候文章可能会有评论，而有时候却没有评论。有时候，加载评论是有意义的，而有时却没有意义。这很好，但是请试着在你的结构方面作出一致的响应。
当你得到一篇文章时，你想加载评论，就像这样：
{
   "status":true,
   "message":"Getting details for article with UUID: 5b8f6db5-7848-490e-95a7-f7146dd2e30c",
   "article":{
      "title":"Sample title 1",
      "description":"Sample description 1",
      "image":"https://domain.com/image-1,jpg",
      "uuid":"eec33d99-e955-408e-a64a-abec3ae052df",
      "comments":[
         {
            "text":"Great article",
            "user":{
               "name":"John Doe",
               "uuid":"5b8f6db5-7848-490e-95a7-f7146dd2e30c"
            }
         },
         {
            "text":"Nice one",
            "user":{
               "name":"Jane Doe",
               "uuid":"2ececb69-d208-46c2-b560-531cb716d25d"
            }
         }
      ]
   }
}
但如果你在下载一系列的文章，或是你刚创建了一篇没有任何评论的文章，那么你应该返回以下内容：
{
   "status":true,
   "message":"Article list was a success",
   "articles":[
      {
         "title":"Sample title 1",
         "description":"Sample description 1",
         "image":"https://domain.com/image-1,jpg",
         "uuid":"eec33d99-e955-408e-a64a-abec3ae052df",
         "comments":[]
      },
      {
         "title":"Sample title 2",
         "description":"Sample description 2",
         "image":"https://domain.com/image-2,jpg",
         "uuid":"b8ee70a8-1128-4670-9368-83953fdf722b",
         "comments":[]
      }
   ]
}
因此，如果客户端期望看到一个评论数组，它们仍然会得到它，但它将只是空的。这样一来，你将不会更改你的模型，也不会删除对象 / 数组。
你只是通过保持一致，就为自己和他人节省了大量的时间。

# 6）要优雅
HTTP 状态代码。如果你不了解，那么 HTTP 的状态代码可以在任何你能想到的情况下使用。HTTP 相应状态代码有 50 多种，每一种都有其特殊的意义，需要在特定的环境中加以应用。
信息型响应代码（以 1xx 开头）。
成功响应代码（以 2xx 开头）。
重定向响应代码（从 3xx 开始）。
客户端错误响应代码（从 4xx 开始）。
服务器错误响应代码（以 5xx 开头）。
因此，你真的拥有你需要的所有状态。从 OK、未授权、未找到、内部服务器错误
无论如何，每个状态都有其意义。这种意义被广泛地接受和了解。所以，无论是中国的开发人员还是德国的开发人员，都会理解，当你发送 401（未授权）的状态时，意味着客户端没有发送正确的认证信息。因为我们响应的状态代码是 401（未授权），所以大家都知道这是客户端故障，必须通过客户端来解决，而非 API。我只是举一个例子，但我的意思是，你应该在适当的情况下使用适当的 HTTP 状态代码。使用它们可以帮助你的 API 得到广泛的理解、一致和标准。虽然 REST 并不是一个标准，但它是你必须遵守的一个标准。
一旦有了 HTTP 的状态代码，我们就必须在遇到困难时给客户提供尽可能多的详细信息。为此，我们需要做许多工作。首先，我们要能预想到 API 的失败，别人会怎么做，哪些事情不会发生，哪些人会违反这些规则。因此，第一步要进行强有力的、严密的数据验证，尤其是在创建内容之前。当你得到数据后，你需要检查这些数据是否有效。这就意味着哟啊检查 ID 是否真实存在，数值是否符合我们的预期，并且可以把它存储到数据库中。完成以上操作，并对相应的状态代码作出响应，将会使你的 API 让人用起来非常愉悦。因此，假定你已经有了一个端点，它接受了 user_id 并获得了用户资料。如果我们应用预测可能发生的事情的策略，我们会做以下的事情：
检查请求中是否有 user_id 参数：如果没有，则回应 400 错误请求。
检查给定的 user_id 是否真的存在于系统中：如果没有，则以 404（未找到）回应。
如果 user_id 返回一个结果，则响应 200（OK）。
正如你所看到的，我们拥有多种故障保险，在所有这些故障中，我们都用正确的、可理解的响应代码进行响应。
最后，一旦我们设置了我们的响应代码，并且预测了 API 可能出现的故障，我们只需要尽可能地表达出来。我知道，对于我们的开发人员而言，这是一件非常困难的事，但是请相信我，这是你能做的最好的事情之一。当事情出错时，REST API 就会有一个通用的错误响应模型。如果我们已经有了这种模型，客户端开发人员就可以依赖于此向用户提供关于哪里出了问题的更详细的解释。那么，让我们来想象一下，有一位用户在自己的手机中发送了一封无效的电子邮件。它以某种方式被传送到 API，API 自然会出发一次确认和错误，并且响应 400（错误请求）。与此同时，API 应当发出一种通用的错误响应模式，使客户端能够将任意或全部的信息显示给终端用户。所以，如果是这样的话，你很有可能会返回一个错误信息：“输入的电子邮件地址无效”。客户端可以读取并将其显示给用户。同样，我们需要确保你能够涵盖所有的问题，包括从验证到服务器的故障。要实现这个目标，我们最好能找到一种适用于各种情景的通用错误模式。我推荐你采用下列方法：
{
   "title":"Invalid data",
   "message":"The data you entered is not valid",
   "errors":[
      {
        "field": "email",
        "message":"The email address you provided is not real"
      },
      {
        "field": "phone_number",
        "message":"You did not enter a phone number at all"
      }
   ]
}
JSON 的错误结构非常简单。我们有一个标题和消息，为我们提供了一个大致的方向，很多时候，开发人员并没有把全部的错误信息展示给最终用户。他们可以在 iPhone 中设置一个警报模式，进现实我们的消息或者标题。但是我们还会发送一个错误数组，它可以容纳具有特定信息的特定错误。提供详细的错误信息将有助于你和其他在 API 上工作的开发者了解到底是什么出了问题。即使你没有讲这些信息展示给最终用户，你也可以在你的要求下，或者你正在使用 Treblle 这样的服务，来看到这些信息。
所以一定要记得，你要尽可能去预测更多的问题。提供大量的细节，说明为什么事情会发生失败，即便是没有人使用，并且使用普遍理解的 HTTP 响应代码的语言。
要聪明
这是一个更具哲理的问题，但是我认为，这是优秀的 REST API 的支柱之一。假如你想想 API 在现代平台、服务或应用程序中的作用，那么我们可以说 API 是整个操作的大脑。理由是，你可能拥有的每一个客户端（iPhone 应用、安卓应用、网站、物联网设备）都会与同一个 API 对话。这意味着我们的 API 在整个生态系统中起着举足轻重的作用，我们的 API 尅解决所有问题。如果我能再加一句，那就是优雅。
一个聪明的 API 首先 要做的就是保护自己最有价值的资源——数据库。这意味着它应该对数据库进行净化、清理，并防止任何不良数据进入数据库。要做到这一点，一定要确认你从应用向客户端发出的一切，并且排除一切看上去不合适的东西。但我们在拒绝某些东西时，也要给用户一个清楚的原因，让他们明白为什么会这样，或者为什么在这种情况下没有发生。
任何优秀、聪明的 API 都能独立处理复杂的流程，而非依靠客户端。最简单的例子是，将一个用户注册到你的应用中。对于所有的客户端，这应该是一个 API 调用。但在后端，API 可以处理所有可能的后勤工作：在 MailChimp 通讯上注册该用户，向 Firebase 存储推送令牌，向用户发送欢迎邮件等等。客户端段不应该为这些事情调用多个 API 端点。如果我们把所有东西都打包到一个端点，那么你就可以很容易地在任何时间点改变流程，而客户端根本无需察觉。API 能够始终对整个商业逻辑和流程进行全面的控制，只要你能从它们那儿获得所需的数据。
请确定 API 是否经过了优化以满足跨平台的需求。当你处理多个平台或设备，如 iPhone、安卓手机、电脑、电视和类似设备时，API 应该能够适应它们。这就意味着 API 必须具有足够的灵活性，以应对可能与其他客户端的不同输入，同时也可以让客户端继续工作。这方面一个很好的例子就是，可调节尺寸的照片，如果你有一个 API，可以提供照片的内容，那么你也许不会希望将 4000x4000 像素的图片发送到手机上，但是你可以将它发送到电视或者网站上。一个聪明的 API 会知道哪个客户端在访问这个端点，并会返回它自己的优化资源，甚至允许客户端请求特定的尺寸。这样的例子还有很多，不过你会明白的。
尽可能减少客户端的依赖性。一个聪明的 API 总是会把客户端的缺陷考虑进去，并且尽量改正。
须简练
如果 API 不能迅速地进行优化，那它算得了什么？in 的 API 不能成为整个生态系统的痛点。就这么简单。有许多方法可以保证你的性能和扩展性都是优秀 API 所应有的。让我们看一下其中的一些。
快速和优化始于数据库层面。每当我听到有人说他们的 API 很慢时，十有八九与数据库有关。数据库设计不佳、查询复杂、基础设施迟缓、缓存不足。你应当总是对数据库结构、查询、索引以及其他与数据库交互作用的所有内容进行优化。当你完成了这一任务之后，接下来要做的就是保证你能够尽可能地提供高速缓存的数据。有时候，缓存数据库查询会使你的加载时间缩短 100%。所以，加入你有 API 断电，可以向用户展示他们的个人资料或者类似的内容，我敢肯定，它不会在每 5 分钟改变。聪明一点，把数据缓存起来。你的用户和调用这个 API 的客户端将会很高兴。
另外一个影响性能的因素是，你将大量的数据通过 API 下发到客户端。一定要保证你的资源和模式只能转回客户端需要的数据，而非全部数据。如果你要返回一个项目的集合，可能你并不需要完全了解模式细节，以及它们之间的关系——每次都是如此。如果这样会加快进度，就这么办。但始终要努力与响应中返回的模型保持一致。这意味着，如果你不加载关系，就返回一个空数组，如果你不加载计数，就返回 0，等等。在建立优秀的 REST APIs 时，一致性是关键。


设身处地为他人着想，尽量让他人的工作更加轻松。构建一个良好的 API，遵循我们在这里定义的规则，编写优秀的文档，服务于他人。
生成的支持 OpenAPI 规范的文档。
实时监控和记录,这样你就可以了解别人在做什么，从而更好地帮助他们。
Treblle

# GraphQL
GraphQL 也是以 JSON 为基础，共享了 REST 的优势，例如灵活性、性能、可扩展性等。
两个主要缺点是：1）是由 Facebook 构建的 2）它把 API 设计过程转移到了客户端。
后端做稳定的API接口，前端可以自行做点临时api接口。


